# The Algorithm Design Manual - Skienna 2nd

Designing correct, efficient, and implementable algorithms for real-world problems requires
access to two distinct bodies of knowledge:
  - `Techniques` – Good algorithm designers understand several fundamental algorithm design techniques, including data structures, dynamic programming,
depth-first search, backtracking, and heuristics. Perhaps the single most important design technique is modeling, the art of abstracting a messy real-world
application into a clean problem suitable for algorithmic attack.
  - `Resources` – Good algorithm designers stand on the shoulders of giants.
Rather than laboring from scratch to produce a new algorithm for every task,
they can figure out what is known about a particular problem. Rather than
re-implementing popular algorithms from scratch, they seek existing implementations to serve as a starting point. They are familiar with many classic
algorithmic problems, which provide sufficient source material to model most
any application.

Table of Contents:
- [1 Introduction to Algorithm Design]()
- [2 Algorithm Analysis]()
- [3 Data Structures]()
- [4 Sorting and Searching]()
- [5 Graph Traversal]()
- [6 Weighted Graph Algorithms]()
- [7 Combinatorial Search and Heuristic Methods]()
- [8 Dynamic Programming]()
- [9 Intractable Problems and Approximation Algorithms]()
- [10 How to Design Algorithms]()
- [11 A Catalog of Algorithmic Problems]()
- [12 Data Structures]()
- [13 Numerical Problems]()
- [14 Combinatorial Problems]()
- [15 Graph Problems: Polynomial-Time]()
- [16 Graph Problems: Hard Problems]()
- [17 Computational Geometry]()
- [18 Set and String Problems]()
- [19 Algorithmic Resources]()

<br>
<br>

---

<br>
<br>

# 1 Introduction to Algorithm Design

### Robot Tour Optimization

### Selecting the Right Jobs

### Reasoning about Correctness

### Modeling the Problem

### About the War Stories

### War Story: Psychic Modeling

### Exercises

<br>
<br>

---

<bR>
<Br>
  
# 2 Algorithm Analysis

### The RAM Model of Computation

### The Big Oh Notation

### Growth Rates and Dominance Relations

### Working with the Big Oh

### Reasoning About Efficiency

### Logarithms and Their Applications

### Properties of Logarithms

### War Story: Mystery of the Pyramids

### Advanced Analysis (*)

### Exercises

<br>
<br>

---

<bR>
<Br>
  
# 3 Data Structures

### Contiguous vs. Linked Data Structures

### Stacks and Queues

### Dictionaries

### Binary Search Trees

### Priority Queues .

### War Story: Stripping Triangulations

### Hashing and Strings

### Specialized Data Structures

### War Story: String ’em Up

### Exercises

<br>
<br>

---

<bR>
<Br>
  
# 4 Sorting and Searching

### Applications of Sorting

### Pragmatics of Sorting

### Heapsort: Fast Sorting via Data Structures 

### War Story: Give me a Ticket on an Airplane

### Mergesort: Sorting by Divide-and-Conquer

### Quicksort: Sorting by Randomization

### Distribution Sort: Sorting via Bucketing

### War Story: Skiena for the Defense

### Binary Search and Related Algorithms 

### Divide-and-Conquer

### Exercises

<br>
<br>

---

<bR>
<Br>
  
# 5 Graph Traversal

### Flavors of Graphs

### Data Structures for Graphs

### War Story: I was a Victim of Moore’s Law 

### War Story: Getting the Graph

### Traversing a Graph

### Breadth-First Search

### Applications of Breadth-First Search

### Depth-First Search

### Applications of Depth-First Search

### Depth-First Search on Directed Graphs

### Exercises

<br>
<br>

---

<bR>
<Br>
  
# 6 Weighted Graph Algorithms

### Minimum Spanning Trees

### War Story: Nothing but Nets

### Shortest Paths 

### War Story: Dialing for Documents

### Network Flows and Bipartite Matching

### Design Graphs, Not Algorithms

### Exercises

<br>
<br>

---

<bR>
<Br>
  
# 7 Combinatorial Search and Heuristic Methods

### Backtracking

### Search Pruning

### Sudoku

### War Story: Covering Chessboards

### Heuristic Search Methods

### War Story: Only it is Not a Radio

### War Story: Annealing Arrays

### Other Heuristic Search Methods

### Parallel Algorithms

### War Story: Going Nowhere Fast

### Exercises

<br>
<br>

---

<bR>
<Br>
  
# 8 Dynamic Programming

### Caching vs. Computation

### Approximate String Matching

### Longest Increasing Sequence

### War Story: Evolution of the Lobster

### The Partition Problem

### Parsing Context-Free Grammars

### Limitations of Dynamic Programming: TSP

### War Story: What’s Past is Prolog

### War Story: Text Compression for Bar Codes

### Exercises

<br>
<br>

---

<bR>
<Br>
  
# 9 Intractable Problems and Approximation Algorithms
 
### Problems and Reductions

### Reductions for Algorithms

### Elementary Hardness Reductions

### Satisfiability .

### Creative Reductions

### The Art of Proving Hardness

### War Story: Hard Against the Clock 

### War Story: And Then I Failed

### P vs. NP

### Dealing with NP-complete Problems

### Exersices

<br>
<br>

---

<bR>
<Br>
  
# 10 How to Design Algorithms

<br>
<br>

---

<bR>
<Br>
  
# 11 A Catalog of Algorithmic Problems

<br>
<br>

---

<bR>
<Br>
  
# 12 Data Structures

### Dictionaries

### Priority Queues

### Suffix Trees and Arrays 

### Graph Data Structures

### Set Data Structures

### Kd-Trees

<br>
<br>

---

<bR>
<Br>
  
# 13 Numerical Problems

### Solving Linear Equations

### Bandwidth Reduction

### Matrix Multiplication 

### Determinants and Permanents

### Constrained and Unconstrained Optimization

### Linear Programming

### Random Number Generation

### Factoring and Primality Testing .

### Arbitrary-Precision Arithmetic

### Knapsack Problem

### Discrete Fourier Transform

<br>
<br>

---

<bR>
<Br>
  
# 14 Combinatorial Problems

### Sorting 

### Searching

### Median and Selection

### Generating Permutations .

### Generating Subsets

### Generating Partitions

### Generating Graphs

### Calendrical Calculations

### Job Scheduling

### Satisfiability

<br>
<br>

---

<bR>
<Br>
  
# 15 Graph Problems: Polynomial-Time

### Connected Components

### Topological Sorting

### Minimum Spanning Tree

### Shortest Path

### Transitive Closure and Reduction

### Matching

### Eulerian Cycle/Chinese Postman

### Edge and Vertex Connectivity

### Network Flow

### Drawing Graphs Nicely

### Drawing Trees

### Planarity Detection and Embedding

<br>
<br>

---

<bR>
<Br>
  
# 16 Graph Problems: Hard Problems

### Clique

### Independent Set

### Vertex Cover

### Traveling Salesman Problem

### Hamiltonian Cycle

### Graph Partition

### Vertex Coloring

### Edge Coloring

### Graph Isomorphism

### Steiner Tree

### Feedback Edge/Vertex Set

<br>
<br>

---

<bR>
<Br>
  
# 17 Computational Geometry

### Robust Geometric Primitives

### Convex Hull

### Triangulation

### Voronoi Diagrams

### Nearest Neighbor Search

### Range Search

### Point Location

### Intersection Detection

### Bin Packing

### Medial-Axis Transform

### Polygon Partitioning

### Simplifying Polygons

### Shape Similarity 

### Motion Planning

### Maintaining Line Arrangements

### Minkowski Sum

<br>
<br>

---

<bR>
<Br>
  
# 18 Set and String Problems

### Set Cover

### Set Packing

### String Matching

### Approximate String Matching

### Text Compression

### Cryptography

### Finite State Machine Minimization

### Longest Common Substring/Subsequence

### Shortest Common Superstring

<br>
<br>

---

<bR>
<Br>
  
# 19 Algorithmic Resources

### Software Systems

### Data Sources

### Online Bibliographic Resources

### Professional Consulting Services


<Br>




