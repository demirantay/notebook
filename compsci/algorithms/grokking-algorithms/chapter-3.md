# Dijktra's Algorithm

### Working with Dijkstra's algorithm

### Terminology

### Trading for a piano

### Negative-weight edges

### Implementation

### Recap

<br>
<br>

---

<Br>
<br>
  
# Greedy Algorithms

### The classroom scheduling problem

### The knapsack problem

### The set-covering problem

- `approximation algorithms` --

### NP-complete problems

### Travelling salesperson, step by step

- `how do you tell if a problem is NP-complete` 

- `recap` --

<br>
<br>

---

<Br>
<Br>
  
# Dynamic Programming

### THe knapscak problem

- `the simple solution` --

- `dynamic programming` --

### Knapsack problem FAQ

- `what happens if you add an item` --

- `what happens if you change the order of the rows` --

- `can you fill in the frid colum wise instead of row-wise` --

- `what happens if you add a smaller item` -- 

- `can you steal fractions of an item?` --

- `optimizing your travel itinerary` --

- `Handling items that depend on each other` --

- `is it possible that the solution will require more than two sub-knapsacks` --

- `Is it possible that the best solution doesnt fill the knapscak completly` --

### Longest common substring

<br>
<br>

---

<br>
<Br>
  
# K-nearest neighbors

### Classifying orange vs grapefruit

### Building a recommendations system

- `feature extraction` --

- `regression` --

- `picking good features` --

### Introduction to machine learning

- `ocr` --

- `building a spam filter` --

- `predicting the stock market` --

- `Recap` --

<br>
<br>

---

<Br>
<br>
  
# Where to go next

### Trees

### Inverted indexes

### The fourier transforms

### Parallel algorithms

### MapReduce

### Bloom filters and HyperLogLog

### The SHA Algorithms

### Locality-sensetive hashing

### Diffie-Hellman key exchange

### Linear Programming 

### Epilogue
