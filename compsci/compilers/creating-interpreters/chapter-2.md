# A Tree-Walk Interpreter

- With this part, we begin jlox, the first of our two interpreters. Programming languages are a huge topic with piles of concepts and terminology to cram into your brain all at once. There’s theory—though not too much in this book—which requires a level of mental rigor that you probably haven’t had to summon since your last Calculus final.

  Implementing an interpreter uses a few architectural tricks and design patterns uncommon in other kinds of applications, so we’ll be getting used to the engineering side of things too. Given all of that, we’ll keep the code we have to write as simple and plain as possible.
  
  In less than two thousand lines of clean Java code, we’ll build a complete interpreter for Lox that implements every single feature of the language, exactly as we’ve specified. The first few chapters work front-to-back through the phases of the interpreter—scanning, parsing, and evaluating code. After that, we add language features one at a time, growing a simple calculator into a full-fledged scripting language.

<br>
<br>

---

<br>
<br>

# Scanning

- The first step in any compiler or interpreter is scanning. The scanner takes in raw source code as a series of characters and groups it into meaningful chunks—the “words” and “punctuation” that make up the language’s grammar.

### The Interpreter Framework

### Tokens and Lexemes

### Regular Languages and Expressions

### The Scanner Class

### Recognizing Lexemes

### Longer Lexemes

### Reserved Words and Identifiers

<br>
<br>

---

<br>
<br>

# Representing Code 


<br>
<br>

---

<br>
<br>

# Parsing Expressions


<br>
<br>

---

<br>
<br>

# Evaluating Expressions


<br>
<br>

---

<br>
<br>

# Statements and State


<br>
<br>

---

<br>
<br>

# Control Flow


<br>
<br>

---

<br>
<br>

# Functions


<br>
<br>

---

<br>
<br>

# Resolving and Binding


<br>
<br>

---

<br>
<br>

# Classes


<br>
<br>

---

<br>
<br>

# Inheritance

<br>
<br>

---

<br>
<br>

# A Bytecode Virtual Machine

<br>
<br>

---

<br>
<br>

# Chunks of Bytecode

<br>
<br>

---

<br>
<br>

# A Virtual Machine

<br>
<br>

---

<br>
<br>

# Scanning on Demand

<br>
<br>

---

<br>
<br>

# Compiling Expressions

<br>
<br>

---

<br>
<br>

# Types of Values

<br>
<br>

---

<br>
<br>

# Strings

<br>
<br>

---

<br>
<br>

# Hash Tables

<br>
<br>

---

<br>
<br>

# Global Variables

<br>
<br>

---

<br>
<br>

# Local Variables

<br>
<br>

---

<br>
<br>

# Jumping Back and Forth

<br>
<br>

---

<br>
<br>

# Calls and Functions

<br>
<br>

---

<br>
<br>

# Closures

<br>
<br>

---

<br>
<br>

# Garbage Collection

<br>
<br>

---

<br>
<br>

# Classes and Instances

<br>
<br>

---

<br>
<br>

# Methods and Initializers

<br>
<br>

---

<br>
<br>

# Superclasses

<br>
<br>

---

<br>
<br>

# Optimization
