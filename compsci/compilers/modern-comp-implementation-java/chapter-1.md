# Modern Compiler Implementation in Java (2nd)

- This textbook describes all phases of a compiler: lexical analysis, parsing, abstract syntax, semantic
actions, intermediate representations, instruction selection via tree matching, dataflow analysis, graphcoloring register allocation, and runtime systems

  The first part of the book, Fundamentals of Compilation, is suitable for a one-semester first course in
compiler design. The second part, Advanced Topics, which includes the compilation of object-oriented
and functional languages, garbage collection, loop optimization, SSA form, instruction scheduling, and
optimization for cache-memory hierarchies, can be used for a second-semester or graduate course.

<br>

> Part I Fundamentals of Compilation

<br>

# 1 Introduction

### Modules and interfaces

### Tools and software

### Data structures for tree languages 

<br>
<br>

---

<br>
<br>

# 2 Lexical Analysis

### Lexical tokens

### Regular expressions

### Finite automata

### Nondeterministic finite automata

### Lexical-analyzer generators

<br>
<br>

---

<br>
<br>

# 3 Parsing

### Context-free grammars

### Predictive parsing

### LR parsing

### Using parser generators

### Error recovery

<br>
<br>

---

<br>
<br>

# 4 Abstract Syntax

### Semantic actions

### Abstract parse trees

### Visitors

<br>
<br>

---

<br>
<br>

# 5 Semantic Analysis

### Symbol tables

### Type-checking MiniJava

<br>
<br>

---

<br>
<br>

# 6 Activation Records

### Stack frames

### Frames in the MiniJava compiler

<br>
<br>

---

<br>
<br>

# 7 Translation to Intermediate Code

### Intermediate representation trees

### Translation into trees

### Declarations

<br>
<br>

---

<br>
<br>

# 8 Basic Blocks and Traces 

### Canonical trees

### Taming conditional branches

<br>
<br>

---

<br>
<br>

# 9 Instruction Selection

### Algorithms for instruction selection

### CISC machines

### Instruction selection for the MiniJava compiler

<br>
<br>

---

<br>
<br>

# 10 Liveness Analysis

### Solution of dataflow equations

### Liveness in the MiniJava compiler

<br>
<br>

---

<br>
<br>

# 11 Register Allocation

### Coloring by simplification

### Coalescing

### Precolored nodes

### Graph-coloring implementation

### Register allocation for trees 

<br>
<br>

---

<br>
<br>

# 12 Putting It All Together 


<br>
<Br>

---

> __`Part II Advanced Topics`__


<br>
<br>

---

<br>
<br>

# 13 Garbage Collection
 
### Mark-and-sweep collection

### Reference counts

### Copying collection

### Generational collection

### Incremental collection

### Bakerâ€™s algorithm

### Interface to the compiler

<br>
<br>

---

<br>
<br>

# 14 Object-Oriented Languages

### Class extension

### Single inheritance of data fields

### Multiple inheritance

### Testing class membership

### Private fields and methods

### Classless languages

### Optimizing object-oriented programs

<br>
<br>

---

<br>
<br>

# 15 Functional Programming Languages

### A simple functional language

### Closures

### Immutable variables

### Inline expansion

### Closure conversion

### Efficient tail recursion

### Lazy evaluation

<br>
<br>

---

<br>
<br>

# 16 Polymorphic Types

### Parametric polymorphism

### Polymorphic type-checking

### Translation of polymorphic programs

### Resolution of static overloading

<br>
<br>

---

<br>
<br>

# 17 Dataflow Analysis

### Intermediate representation for flow analysis

### Various dataflow analyses

### Transformations using dataflow analysis

### Speeding up dataflow analysis

### Alias analysis

<br>
<br>

---

<br>
<br>

# 18 Loop Optimizations

### Dominators

### Loop-invariant computations

### Induction variables

### Array-bounds checks

### Loop unrolling

<br>
<br>

---

<br>
<br>

# 19 Static Single-Assignment Form

### Converting to SSA form

### Efficient computation of the dominator tree

### Optimization algorithms using SSA

### Arrays, pointers, and memory

### The control-dependence graph

### Converting back from SSA form

### A functional intermediate form

<br>
<br>

---

<br>
<br>

# 20 Pipelining and Scheduling 

### Loop scheduling without resource bounds

### Resource-bounded loop pipelining

### Branch prediction

<br>
<br>

---

<br>
<br>

# 21 The Memory Hierarchy

### Cache organization

### Cache-block alignment

### Prefetching

### Loop interchange

### Blocking

### Garbage collection and the memory hierarchy

<br>
<br>

---

<br>
<br>

# Appendix: MiniJava Language Reference Manual

### Lexical Issues

### Grammar

### Sample Program

<br>
<br>



