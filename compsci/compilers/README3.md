# Intermediate Code Generation

- A source code can directly be translated into its target machine code, then why at all we need to translate the source code into an intermediate code which is then translated to its target code? Let us see the reasons why we need an intermediate code.
  ```
  source code -> intermediate code -> target code
  ```
  - If a compiler translates the source language to its target machine language without having the option for generating intermediate code, then for each new machine, a full native compiler is required.
  - Intermediate code eliminates the need of a new full compiler for every unique machine by keeping the analysis portion same for all the compilers.
  - The second part of compiler, synthesis, is changed according to the target machine.
  - It becomes easier to apply the source code modifications to improve code performance by applying code optimization techniques on the center intermediate code. Than it can be committed to the machine branches.
  
- Intermediate codes can be represented in a variety of ways and they have their own benefits.
  - `High Level IR` - High-level intermediate code representation is very close to the source language itself. But for target machine optimization, it is less preferred.
  - `Low Level IR` - This one is close to the target machine, which makes it suitable for register and memory allocation, instruction set selection, etc. It is good for machine-dependent optimizations.
  
### Three-Address Code

- Intermediate code generator receives input from its predecessor phase, semantic analyzer, in the form of an annotated syntax tree. That syntax tree then can be converted into a linear representation, e.g., postfix notation. Intermediate code tends to be machine independent code. Therefore, code generator assumes to have unlimited number of memory storage (register) to generate code.

<br>
<br>

---

<br>
<br>

# Code Generation

- Code generation can be considered as the final phase of compilation. Through post code generation, optimization process can be applied on the code, but that can be seen as a part of code generation phase itself. The code generated by the compiler is an object code of some lower-level programming language,

- `Directed Acyclic Graph` -- Directed Acyclic Graph (DAG) is a tool that depicts the structure of basic blocks, helps to see the flow of values flowing among the basic blocks, and offers optimization too. DAG provides easy transformation on basic blocks

### Code Generator

- A code generator is expected to have an understanding of the target machine’s runtime environment and its instruction set. The code generator should take the following things into consideration to generate the code:
  - `Target language` : The code generator has to be aware of the nature of the target language for which the code is to be transformed.
  - `IR Type` : Intermediate representation has various forms. It can be in Abstract Syntax Tree (AST) structure, Reverse Polish Notation, or 3-address code.
  - `Selection of instruction` : The code generator takes Intermediate Representation as input and converts (maps) it into target machine’s instruction set.
  - `Register allocation` : A program has a number of values to be maintained during the execution
  - `Ordering of instructions` : At last, the code generator decides the order in which the instruction will be executed.

### Descriptors

- The code generator has to track both the registers (for availability) and addresses (location of values) while generating the code. For both of them, the following two descriptors are used:
  - `Register descriptor` : Register descriptor is used to inform the code generator about the availability of registers
  - `Address descriptor` : Values of the names (identifiers) used in the program might be stored at different locations while in execution. Address descriptors are used to keep track of memory locations where the values of identifiers are stored. 

<br>
<br>

---

<Br>
<br>

# Code Optimization

- Optimization is a program transformation technique, which tries to improve the code by making it consume less resources (i.e. CPU, Memory) and deliver high speed. In optimization, high-level general programming constructs are replaced by very efficient low-level programming codes. A code optimizing process must follow the three rules given below:
  - The output code must not, in any way, change the meaning of the program.
  - Optimization should increase the speed of the program and if possible, the program should demand less number of resources.
  
  Efforts for an optimized code can be made at various levels of compiling the process.
  - At the beginning, users can change/rearrange the code or use better algorithms to write the code
  - After generating intermediate code, the compiler can modify the intermediate code by address calculations and improving loops.
  - While producing the target machine code, the compiler can make use of memory hierarchy and CPU registers.
  
  > Optimization can be categorized broadly into two types : machine independent and machine dependent.

- `Machine-independent Optimization` -- In this optimization, the compiler takes in the intermediate code and transforms a part of the code that does not involve any CPU registers and/or absolute memory locations

- `Machine-dependent Optimization` -- Machine-dependent optimization is done after the target code has been generated and when the code is transformed according to the target machine architecture. It involves CPU registers and may have absolute memory references rather than relative references. Machine-dependent optimizers put efforts to take maximum advantage of memory hierarchy.

### Loop Optimization

- Most programs run as a loop in the system. It becomes necessary to optimize the loops in order to save CPU cycles and memory. Loops can be optimized by the following techniques
  - `Invariant code` : A fragment of code that resides in the loop and computes the same value at each iteration is called a loop-invariant code. This code can be moved out of the loop by saving it to be computed only once, rather than with each iteration.
  - ... etc. search for papers on compiler loop optimizations

### Dead-code Elimination

- Dead code is one or more than one code statements, which are:
  - Either never executed or unreachable,
  - Or if executed, their output is never used.
  
  Thus, dead code plays no role in any program operation and therefore it can simply be eliminated.

<br>
<br>
