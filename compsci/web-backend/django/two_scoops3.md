# Templates: Best Practices

- One of Django’s early design decisions was to limit the functionality of the template language. This
heavily constrains what can be done with Django templates, which we often think is a very good
thing since it forces us to keep business logic in the Python side of things.

### Keep Templates Mostly in templates/ 

- In our projects, we keep the majority of our templates in the main ‘templates/’ directory. We put
subdirectories in ‘templates/’ to correspond to each of our apps, as shown here:
  ```
  templates/
  ├── base.html
  ├── ... (other sitewide templates in here)
  ├── freezers/
  │   ├── ("freezers" app templates in here)
  ```

### Template Architecture Patterns

- `3-Tier Template Architecture Example` -- With a 3-tier template architecture:
  ```
  templates/
      base.html
      dashboard.html # extends base.html
      profiles/
          base_profiles.html # extends base.html
          profile_detail.html # extends base_profiles.html
          profile_form.html # extends base_profiles.html
  ```
  The 3-tier architecture is best for websites where each section requires a distinctive layout.
  
  Complex template hierarchies make it exceedingly difficult to debug, modify, and extend HTML
pages and tie in CSS styles. When template block layouts become unnecessarily nested, you end up
digging through file after file just to change, say, the width of a box

### Limit Processing in Templates

- The less processing you try to do in your templates, the better. This is particularly a problem when it
comes to queries and iteration performed in the template layer

  Whenever you iterate over a queryset in a template, ask yourself the following questions:
  - 1 - How large is the queryset? Looping over gigantic querysets in your templates is almost always
a bad idea.
  - 2 - How large are the objects being retrieved? Are all the fields needed in this template?
  - 3 - During each iteration of the loop, how much processing occurs?

### Don’t Bother Making Your Generated HTML Pretty

- Bluntly put, no one cares if the HTML generated by your Django project is attractive. In fact, if
someone were to look at your rendered HTML, they’d do so through the lens of a browser inspector,
which would realign the HTML spacing anyway. Therefore, if you shuffle up the code in your Django
templates to render pretty HTML, you are wasting time obfuscating your code for an audience of
yourself.

  Dont waste your hours on it but still keep a neatly orginized html because a messy one can hinder a lot of development
  
  Are you worried about the volume of whitespace generated? Don’t be. First of all, experienced developers favor readability of code over obfuscation for the sake of optimization. Second, there are
compression and minification tools that can help more than anything you can do manually here.

### Useful Things to Consider

- Aim to control the styling of all rendered templates entirely via CSS and JS.
Use CSS for styling whenever possible. Never hardcode things like menu bar widths and color choices
into your Python code

###  Error Page Templates

- Even the most tested and analyzed site will have a few problems now and then, and that’s okay. The
problem lies in how you handle those errors. The last thing that you want to do is show an ugly
response or a blank web server page back to the end user.

  It’s standard practice to create at least 404.html and 500.html templates
  
  We suggest serving your error pages from a static file server (e.g. Nginx or Apache) as entirely selfcontained static HTML files. That way, if your entire Django site goes down but your static file server
is still up

<Br>
<Br>
<Br>
  
# Template Tags and Filters

- Django provides dozens of default template tags and filters, all of which share the following common
traits:
  - ➤ All of the defaults have clear, obvious names.
  - ➤ All of the defaults do just one thing
  - ➤ None of the defaults alter any sort of persistent data.

### Filters Are Functions

- Filters are functions that accept just one or two arguments, and that don’t give developers the ability
to add behavior controls in Django templates

  Since filters are just functions, we advocate that anything but the simplest logic for them be moved
to more reusable utility functions, perhaps stored in a utils.py module. Doing this makes it easier to introspect code bases and test, and can mean dramatically fewer imports. Over time core Django has
followed this pattern more and more.

### Custom Template Tags

- While template tags are great tools when developers have the discipline to keep them in check, in
practice they tend to get abused

- Template tags of any complexity can be challenging to debug.When they include opening and closing
elements, they become even harder to handle. We’ve found liberal use of log statements and tests are
very helpful when they become hard to inspect and correct.

- Template tags can have a significant performance cost, especially when they load other templates.
While templates run much faster than they did in pre-1.8 versions of Django, it’s easy to lose those
performance benefits if you don’t have a deep understanding of how templates are loaded in Django.

- `When to use template tags` -- When should you write new template tags? We recommend writing them in situations where they are
only responsible for rendering of HTML. For example, projects with very complex HTML layouts
with many different models or data types might use them to create a more flexible, understandable
template architecture.

### Naming Your Template Tag Libraries

- The convention we follow is <app_name>_tags.py.
  - blog_tags.py
  - events_tags.py
  - tickets_tags.py

### Loading Your Template Tag Modules

- In your template, right after {% extends "base.html" %} (or any other parent template besides
base.html) is where you load your template tags:
  ```html
  {% extends "base.html" %}

  {% load flavors_tags %}
  ```
  you can check django docs for tag info. This book is dedicated for best practices.

<Br>
<Br>
<Br>
  
# Django Templates and Jinja2

- With Django 1.8 came support for multiple template engines. As of now, the only available built-in
backends for the Django template system are the Django template language (DTL) and Jinja2.

### What’s the Syntactical Difference?

- At the syntax level, DTL and Jinja2 are very similar. In fact, Jinja2 was inspired by DTL. Here are
the most significant syntax differences:

  |Subject | DTL|Jinja2|
  |--|--|--|
  |Method Calls| {{ user.get_favorites }} |{{ user.get_favorites() }} |
  |Filter Arguments | {{ toppings|join:', ' }} | {{ toppings|join(', ') }} |
  |Loop Empty Argument | {% empty %} | {% else %} |
  |Loop Variable | {{ forloop }} | {{ loop }} |
  |Cycle | {% cycle 'odd' 'even' %} | {{ loop.cycle('odd','even') }} |
  
  ...etc.

### Should I Switch?

- In short, we can use multiple template languages together harmoniously, so you dont have to stick to one but if you are changing from DTL have a good reason.

<Br>
<Br>
<Br>
  
# Building REST APIs With Django REST Framework

- Today’s internet is much more than HTML-powered websites. Developers need to support AJAX
and native mobile apps. Having tools that support easy creation of JSON, YAML, XML, and other
formats is important. By design, a Representational State Transfer (REST) Application Programming Interface (API) exposes application data to other concerns.

  The defacto package for building these REST APIs with Django is Django REST Framework
(DRF).
  
- `WARNING` -- Sequential keys, such as what Django provides as a default as model primary keys, can be
a security concern if used publicly. We cover this in-depth at Section 26.27: Never Display
Sequential Primary Keys.
In our example, we’re going to use the model’s UUID rather than the model’s primary key to
look up our records. We always try to avoid using sequential numbers for lookups. 

### REST API Architecture

- Building simple, quick APIs is easy with Django REST Framework, but extending and maintaining
it to match your project’s needs takes a bit more thought. This is usually where people get hung up
on API design. Here are some tips for improving your design:

- `Use Consistent API Module Naming` -- Just like anything else, how things are named needs to be consistent across a project. Our preferences
for naming module related to API design is as follows:
  ```
  django_app/
  ├── api/
  │   ├── __init__.py
  │   ├── authentication.py
  │   ├── parsers.py
  │   ├── permissions.py
  │   ├── renderers.py
  │   ├── serializers.py
  │   ├── validators.py
  │   ├── views.py
  │   ├── viewsets.py
  ```
  -  We like to place all our API components into a package within an app called api/. That’s allows
us to isolate our API components in a consistent location. If we were to put it in the root of
our app, then we would end up with a huge list of API-specific modules in the general area of
the app
  - We always place routers in urls.py.
  
- `Try to Keep Business Logic Out of API Views` -- Regardless of which architectural approach you take, it’s a good idea to try to keep as much logic as
possible out of API views. If this sounds familiar, it should. We covered this in Section 8.5: Try to
Keep Business Logic Out of Views. Remember, at the end of the day, API views are just another
type of view

- `Grouping API urls` -- If you have REST API views in multiple Django apps, how do you build a project-wide API that
looks like this?
  ```
  api/flavors/ # GET, POST
  api/flavors/:uuid/ # GET, PUT, DELETE
  api/users/ # GET, POST
  api/users/:uuid/ # GET, PUT, DELETE
  ```
  Our current approach is to lean on URL configuration. When building a project-wide API we write
the REST views in the api/views.py or api/viewsets.py modules, wire them into a URLConf called
something like core/api_urls.py or core/apiv1_urls.py, and include that from the project root’s urls.py
module

- When we implement a new version of the API, we provide customers/users with a deprecation warning along with ample time so they can perform necessary upgrades and not break their own applications. From personal experience, the ability to send a deprecation warning to end users is an excellent
reason to request email addresses from users of even free and open source API services.

### Shutting Down an External API

- When it’s time to shut down an older version of an external API in favor of a new one, here are useful
steps to follow:
  - Step #1: Notify Users of Pending Shut Down
  - Step #2: Replace API With 410 Error View

### Rate-Limiting Your API

- Rate limiting is when an API restricts how many requests can be made by a user of the API within
a period of time. This is done for a number of reasons

  > It’s possible to use nginx or apache for rate limiting. The upside is faster performance. The
downside is that it removes this functionality from the Python code.

- Also Rate Limit Can Be a Business Plan We know that everyone will want to use this API, and come up with several tiers of access
that we tie into pricing:
  - Developer tier is free, but only allows 10 API requests per hour.
  - Two Scoops is $79/month, allows 50 requests per minute.
  - Corporate is $5000/month, allows for 200 requests per minute.

### Advertising Your REST API

- Let’s assume we’ve built our REST API and want outside coders and companies to use it. How do
we go about doing that?

- `Documentation` -- The most important thing to do is to provide comprehensive documentation. The easier to read
and understand the better. (Use slacks documentation as a inspiration it is fucking documented VERY WELL)

- `Provide Client SDKs` -- Something that may help spread use of your API is to provide a software development kits (SDK)
for various programming languages. The more programming languages covered the better. For us,
we’ve found the must-have languages include Python, JavaScript, Ruby, PHP, Go, and Java

<Br>
<Br>
<Br>
  
# Tradeoffs of Replacing Core Components

- There’s a lot of hype around swapping out core parts of Django’s stack for other pieces. Should you
do it?

  Short Answer: Don’t do it. Even the CEO of Instagram (Kevin Systrom) said Forbes.com that it’s
completely unnecessary (bit.ly/2pZxOBO).

###  Ignore the Hype and Do Your Own Research

- It’s often said that non-relational databases are faster and scale better than relational databases.
Whether or not this is true, don’t blindly swallow the marketing hype of the companies behind
any particular alternative database solution.

  Instead, do as we do: search for benchmarks, read case studies describing when things went right or
wrong, and form opinions as independently as possible

  Also, experiment with unfamiliar NoSQL databases on small hobby side projects before you make
major changes to your main project infrastructure. Your main codebase is not a playground.

<Br>
<Br>
<Br>
  
# Working With the Django Admin

- When people ask, “What are the benefits of Django over other web frameworks?” the admin is what
usually comes to mind. It gives you so much power over your web application
automatically, with little work required.

### Admin Customization vs. New Views

- It’s usually not worth it to heavily customize the Django admin. Sometimes, creating a simple view
or form from scratch results in the same desired functionality with a lot less work. We’ve always had
better results with creating custom management dashboards for client projects than we have with
modifying the admin to fit the need of the client.

  So basic motto is __use django admin untill you really need a custom admin where you will build it from scratch__

### Viewing String Representations of Objects

- If you want to change the admin list display in a way that isn’t quite a string representation of the
object, then use `list_display`.
  ```python
  # admin.py 
  from django.contrib import admin
  from .models import IceCreamBar
    
  @admin.register(IceCreamBar)
  class IceCreamBarModelAdmin(admin.ModelAdmin):
      list_display = ('name', 'shell', 'filling')
  ```
  This will list more than just the `__str__` returned from the model. It will return name, shell, filling columns 

### Using Custom Skins With the Django Admin

- You can have custom designs that are already mature and easy to import into your own application:
  - django-grappelli (most stable one)
  - django-suit
  - django-admin-bootstrapped 

### Secure the Django Admin

- Since the Django admin gives your site admins special powers that ordinary users don’t have, it’s good
practice to make it extra secure.

- `Change the Default Admin URL` -- By default, the admin URL is yoursite.com/admin/. Change it to something that’s long and difficult
to guess.

- If you’re particularly concerned about people trying to break into your Django site, `django-admin-honeypot` is a package that puts a fake Django admin login screen at admin/ and logs information
about anyone who attempts to log in.

- This is already implied in Section 26.6: HTTPS Everywhere, but we want to especially emphasize
here that your admin needs to be TLS-secured. If your site allows straight HTTP access, you will
need to run the admin on a properly-secured domain, adding to the complexity of your deployment Without TLS, if you log into your Django admin on an open WiFi network, it’s trivial for someone
to sniff your admin username/password.

- Configure your web server to only allow access to the Django admin to certain IP addresses. Look
up the instructions for your particular web server.

<Br>
<Br>
<Br>
  
# Dealing With the User Model

- Django comes with a built-in support for user records. It’s a useful feature, doubly so once you learn
how to extend and expand on the basic functionality

- In Django 1.11, the official preferred way to attach ForeignKey, OneToOneField, or ManyToManyField to User is as follows:
  ```python
  from django.conf import settings
  from django.db import models
  
  class IceCreamStore(models.Model):
      owner = models.OneToOneField(settings.AUTH_USER_MODEL)
      title = models.CharField(max_length=255)
  ```

### Custom User Fields for Django 1.11 Projects

- In Django 1.11, as long as we incorporate the required methods and attributes, we can create our
own user model with its own fields. But if you dont want that hassel you can always create normal user models with a hashing, and salting library for its passowrd protection and than you are good to go.

  There are many ways to improve the user model with its own fields but the most readable way to do it with django user model is the following `relational option`:
  ```python
  from django.conf import settings
  from django.db import models
  
  rom flavors.models import Flavor
  class EaterProfile(models.Model):
      # Default user profile
      # If you do this you need to either have a post_save signal or
      # redirect to a profile_edit view on initial login.
      user = models.OneToOneField(settings.AUTH_USER_MODEL)
      favorite_ice_cream = models.ForeignKey(Flavor, null=True, blank=True)
      
  class ScooperProfile(models.Model):
      user = models.OneToOneField(settings.AUTH_USER_MODEL)
      scoops_scooped = models.IntegerField(default=0)
      
  class InventorProfile(models.Model):
      user = models.OneToOneField(settings.AUTH_USER_MODEL)
      flavors_invented = models.ManyToManyField(Flavor, null=True, blank=True)
  ```
  But as I said creating your own User models are better. It is like django admin use it untill it no longer satisfies your program. And build a new one from scratch at that point.

<Br>
<Br>
<Br>
  
