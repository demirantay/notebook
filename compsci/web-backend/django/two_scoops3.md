# Templates: Best Practices

- One of Django’s early design decisions was to limit the functionality of the template language. This
heavily constrains what can be done with Django templates, which we often think is a very good
thing since it forces us to keep business logic in the Python side of things.

### Keep Templates Mostly in templates/ 

- In our projects, we keep the majority of our templates in the main ‘templates/’ directory. We put
subdirectories in ‘templates/’ to correspond to each of our apps, as shown here:
  ```
  templates/
  ├── base.html
  ├── ... (other sitewide templates in here)
  ├── freezers/
  │   ├── ("freezers" app templates in here)
  ```

### Template Architecture Patterns

- `3-Tier Template Architecture Example` -- With a 3-tier template architecture:
  ```
  templates/
      base.html
      dashboard.html # extends base.html
      profiles/
          base_profiles.html # extends base.html
          profile_detail.html # extends base_profiles.html
          profile_form.html # extends base_profiles.html
  ```
  The 3-tier architecture is best for websites where each section requires a distinctive layout.
  
  Complex template hierarchies make it exceedingly difficult to debug, modify, and extend HTML
pages and tie in CSS styles. When template block layouts become unnecessarily nested, you end up
digging through file after file just to change, say, the width of a box

### Limit Processing in Templates

- The less processing you try to do in your templates, the better. This is particularly a problem when it
comes to queries and iteration performed in the template layer

  Whenever you iterate over a queryset in a template, ask yourself the following questions:
  - 1 - How large is the queryset? Looping over gigantic querysets in your templates is almost always
a bad idea.
  - 2 - How large are the objects being retrieved? Are all the fields needed in this template?
  - 3 - During each iteration of the loop, how much processing occurs?

### Don’t Bother Making Your Generated HTML Pretty

- Bluntly put, no one cares if the HTML generated by your Django project is attractive. In fact, if
someone were to look at your rendered HTML, they’d do so through the lens of a browser inspector,
which would realign the HTML spacing anyway. Therefore, if you shuffle up the code in your Django
templates to render pretty HTML, you are wasting time obfuscating your code for an audience of
yourself.

  Dont waste your hours on it but still keep a neatly orginized html because a messy one can hinder a lot of development
  
  Are you worried about the volume of whitespace generated? Don’t be. First of all, experienced developers favor readability of code over obfuscation for the sake of optimization. Second, there are
compression and minification tools that can help more than anything you can do manually here.

### Useful Things to Consider

- Aim to control the styling of all rendered templates entirely via CSS and JS.
Use CSS for styling whenever possible. Never hardcode things like menu bar widths and color choices
into your Python code

###  Error Page Templates

- Even the most tested and analyzed site will have a few problems now and then, and that’s okay. The
problem lies in how you handle those errors. The last thing that you want to do is show an ugly
response or a blank web server page back to the end user.

  It’s standard practice to create at least 404.html and 500.html templates
  
  We suggest serving your error pages from a static file server (e.g. Nginx or Apache) as entirely selfcontained static HTML files. That way, if your entire Django site goes down but your static file server
is still up

<Br>
<Br>
<Br>
  
# Template Tags and Filters

- Django provides dozens of default template tags and filters, all of which share the following common
traits:
  - ➤ All of the defaults have clear, obvious names.
  - ➤ All of the defaults do just one thing
  - ➤ None of the defaults alter any sort of persistent data.

### Filters Are Functions

- Filters are functions that accept just one or two arguments, and that don’t give developers the ability
to add behavior controls in Django templates

  Since filters are just functions, we advocate that anything but the simplest logic for them be moved
to more reusable utility functions, perhaps stored in a utils.py module. Doing this makes it easier to introspect code bases and test, and can mean dramatically fewer imports. Over time core Django has
followed this pattern more and more.

### Custom Template Tags

- While template tags are great tools when developers have the discipline to keep them in check, in
practice they tend to get abused

- Template tags of any complexity can be challenging to debug.When they include opening and closing
elements, they become even harder to handle. We’ve found liberal use of log statements and tests are
very helpful when they become hard to inspect and correct.

- Template tags can have a significant performance cost, especially when they load other templates.
While templates run much faster than they did in pre-1.8 versions of Django, it’s easy to lose those
performance benefits if you don’t have a deep understanding of how templates are loaded in Django.

- `When to use template tags` -- When should you write new template tags? We recommend writing them in situations where they are
only responsible for rendering of HTML. For example, projects with very complex HTML layouts
with many different models or data types might use them to create a more flexible, understandable
template architecture.

### Naming Your Template Tag Libraries

- The convention we follow is <app_name>_tags.py.
  - blog_tags.py
  - events_tags.py
  - tickets_tags.py

### Loading Your Template Tag Modules

- In your template, right after {% extends "base.html" %} (or any other parent template besides
base.html) is where you load your template tags:
  ```html
  {% extends "base.html" %}

  {% load flavors_tags %}
  ```
  you can check django docs for tag info. This book is dedicated for best practices.

<Br>
<Br>
<Br>
  
# Django Templates and Jinja2

- With Django 1.8 came support for multiple template engines. As of now, the only available built-in
backends for the Django template system are the Django template language (DTL) and Jinja2.

### What’s the Syntactical Difference?

- At the syntax level, DTL and Jinja2 are very similar. In fact, Jinja2 was inspired by DTL. Here are
the most significant syntax differences:

  |Subject | DTL|Jinja2|
  |--|--|--|
  |Method Calls| {{ user.get_favorites }} |{{ user.get_favorites() }} |
  |Filter Arguments | {{ toppings|join:', ' }} | {{ toppings|join(', ') }} |
  |Loop Empty Argument | {% empty %} | {% else %} |
  |Loop Variable | {{ forloop }} | {{ loop }} |
  |Cycle | {% cycle 'odd' 'even' %} | {{ loop.cycle('odd','even') }} |
  
  ...etc.

### Should I Switch?

- In short, we can use multiple template languages together harmoniously, so you dont have to stick to one but if you are changing from DTL have a good reason.

<Br>
<Br>
<Br>
  
# Building REST APIs With Django REST Framework

- Today’s internet is much more than HTML-powered websites. Developers need to support AJAX
and native mobile apps. Having tools that support easy creation of JSON, YAML, XML, and other
formats is important. By design, a Representational State Transfer (REST) Application Programming Interface (API) exposes application data to other concerns.

  The defacto package for building these REST APIs with Django is Django REST Framework
(DRF).
  
- `WARNING` -- Sequential keys, such as what Django provides as a default as model primary keys, can be
a security concern if used publicly. We cover this in-depth at Section 26.27: Never Display
Sequential Primary Keys.
In our example, we’re going to use the model’s UUID rather than the model’s primary key to
look up our records. We always try to avoid using sequential numbers for lookups. 

### REST API Architecture

- Building simple, quick APIs is easy with Django REST Framework, but extending and maintaining
it to match your project’s needs takes a bit more thought. This is usually where people get hung up
on API design. Here are some tips for improving your design:

- `Use Consistent API Module Naming` -- Just like anything else, how things are named needs to be consistent across a project. Our preferences
for naming module related to API design is as follows:
  ```
  django_app/
  ├── api/
  │   ├── __init__.py
  │   ├── authentication.py
  │   ├── parsers.py
  │   ├── permissions.py
  │   ├── renderers.py
  │   ├── serializers.py
  │   ├── validators.py
  │   ├── views.py
  │   ├── viewsets.py
  ```
  -  We like to place all our API components into a package within an app called api/. That’s allows
us to isolate our API components in a consistent location. If we were to put it in the root of
our app, then we would end up with a huge list of API-specific modules in the general area of
the app
  - We always place routers in urls.py.
  
- `Try to Keep Business Logic Out of API Views` -- Regardless of which architectural approach you take, it’s a good idea to try to keep as much logic as
possible out of API views. If this sounds familiar, it should. We covered this in Section 8.5: Try to
Keep Business Logic Out of Views. Remember, at the end of the day, API views are just another
type of view

- `Grouping API urls` -- If you have REST API views in multiple Django apps, how do you build a project-wide API that
looks like this?
  ```
  api/flavors/ # GET, POST
  api/flavors/:uuid/ # GET, PUT, DELETE
  api/users/ # GET, POST
  api/users/:uuid/ # GET, PUT, DELETE
  ```
  Our current approach is to lean on URL configuration. When building a project-wide API we write
the REST views in the api/views.py or api/viewsets.py modules, wire them into a URLConf called
something like core/api_urls.py or core/apiv1_urls.py, and include that from the project root’s urls.py
module

- When we implement a new version of the API, we provide customers/users with a deprecation warning along with ample time so they can perform necessary upgrades and not break their own applications. From personal experience, the ability to send a deprecation warning to end users is an excellent
reason to request email addresses from users of even free and open source API services.

### Shutting Down an External API

- When it’s time to shut down an older version of an external API in favor of a new one, here are useful
steps to follow:
  - Step #1: Notify Users of Pending Shut Down
  - Step #2: Replace API With 410 Error View

### Rate-Limiting Your API

### Advertising Your REST API

### Additional Reading

<Br>
<Br>
<Br>
  
# Consuming REST APIs

### Learn How to Debug the Client

### Consider Using JavaScript-Powered Static Asset Preprocessors

### Real-Time Woes a.k.a. Latency

### Avoid the Anti-Patterns

### AJAX and the CSRF Token

### Improving JavaScript Skills

### Follow JavaScript Coding Standards

<Br>
<Br> 
<Br>
  
