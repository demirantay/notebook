# Templates: Best Practices

- One of Django’s early design decisions was to limit the functionality of the template language. This
heavily constrains what can be done with Django templates, which we often think is a very good
thing since it forces us to keep business logic in the Python side of things.

### Keep Templates Mostly in templates/ 

- In our projects, we keep the majority of our templates in the main ‘templates/’ directory. We put
subdirectories in ‘templates/’ to correspond to each of our apps, as shown here:
  ```
  templates/
  ├── base.html
  ├── ... (other sitewide templates in here)
  ├── freezers/
  │   ├── ("freezers" app templates in here)
  ```

### Template Architecture Patterns

- `3-Tier Template Architecture Example` -- With a 3-tier template architecture:
  ```
  templates/
      base.html
      dashboard.html # extends base.html
      profiles/
          base_profiles.html # extends base.html
          profile_detail.html # extends base_profiles.html
          profile_form.html # extends base_profiles.html
  ```
  The 3-tier architecture is best for websites where each section requires a distinctive layout.
  
  Complex template hierarchies make it exceedingly difficult to debug, modify, and extend HTML
pages and tie in CSS styles. When template block layouts become unnecessarily nested, you end up
digging through file after file just to change, say, the width of a box

### Limit Processing in Templates

- The less processing you try to do in your templates, the better. This is particularly a problem when it
comes to queries and iteration performed in the template layer

  Whenever you iterate over a queryset in a template, ask yourself the following questions:
  - 1 - How large is the queryset? Looping over gigantic querysets in your templates is almost always
a bad idea.
  - 2 - How large are the objects being retrieved? Are all the fields needed in this template?
  - 3 - During each iteration of the loop, how much processing occurs?

### Don’t Bother Making Your Generated HTML Pretty

- Bluntly put, no one cares if the HTML generated by your Django project is attractive. In fact, if
someone were to look at your rendered HTML, they’d do so through the lens of a browser inspector,
which would realign the HTML spacing anyway. Therefore, if you shuffle up the code in your Django
templates to render pretty HTML, you are wasting time obfuscating your code for an audience of
yourself.

  Dont waste your hours on it but still keep a neatly orginized html because a messy one can hinder a lot of development
  
  Are you worried about the volume of whitespace generated? Don’t be. First of all, experienced developers favor readability of code over obfuscation for the sake of optimization. Second, there are
compression and minification tools that can help more than anything you can do manually here.

### Useful Things to Consider

- Aim to control the styling of all rendered templates entirely via CSS and JS.
Use CSS for styling whenever possible. Never hardcode things like menu bar widths and color choices
into your Python code

###  Error Page Templates

- Even the most tested and analyzed site will have a few problems now and then, and that’s okay. The
problem lies in how you handle those errors. The last thing that you want to do is show an ugly
response or a blank web server page back to the end user.

  It’s standard practice to create at least 404.html and 500.html templates
  
  We suggest serving your error pages from a static file server (e.g. Nginx or Apache) as entirely selfcontained static HTML files. That way, if your entire Django site goes down but your static file server
is still up

<Br>
<Br>
<Br>
  
# Template Tags and Filters

- Django provides dozens of default template tags and filters, all of which share the following common
traits:
  - ➤ All of the defaults have clear, obvious names.
  - ➤ All of the defaults do just one thing
  - ➤ None of the defaults alter any sort of persistent data.

### Filters Are Functions

- Filters are functions that accept just one or two arguments, and that don’t give developers the ability
to add behavior controls in Django templates

  Since filters are just functions, we advocate that anything but the simplest logic for them be moved
to more reusable utility functions, perhaps stored in a utils.py module. Doing this makes it easier to introspect code bases and test, and can mean dramatically fewer imports. Over time core Django has
followed this pattern more and more.

### Custom Template Tags

- While template tags are great tools when developers have the discipline to keep them in check, in
practice they tend to get abused

- Template tags of any complexity can be challenging to debug.When they include opening and closing
elements, they become even harder to handle. We’ve found liberal use of log statements and tests are
very helpful when they become hard to inspect and correct.

- Template tags can have a significant performance cost, especially when they load other templates.
While templates run much faster than they did in pre-1.8 versions of Django, it’s easy to lose those
performance benefits if you don’t have a deep understanding of how templates are loaded in Django.

- `When to use template tags` -- When should you write new template tags? We recommend writing them in situations where they are
only responsible for rendering of HTML. For example, projects with very complex HTML layouts
with many different models or data types might use them to create a more flexible, understandable
template architecture.

### Naming Your Template Tag Libraries

- The convention we follow is <app_name>_tags.py.
  - blog_tags.py
  - events_tags.py
  - tickets_tags.py

### Loading Your Template Tag Modules

- In your template, right after {% extends "base.html" %} (or any other parent template besides
base.html) is where you load your template tags:
  ```html
  {% extends "base.html" %}

  {% load flavors_tags %}
  ```
  you can check django docs for tag info. This book is dedicated for best practices.

<Br>
<Br>
<Br>
  
# Django Templates and Jinja2

- With Django 1.8 came support for multiple template engines. As of now, the only available built-in
backends for the Django template system are the Django template language (DTL) and Jinja2.

### What’s the Syntactical Difference?

- At the syntax level, DTL and Jinja2 are very similar. In fact, Jinja2 was inspired by DTL. Here are
the most significant syntax differences:

  |Subject | DTL|Jinja2|
  |--|--|--|
  |Method Calls| {{ user.get_favorites }} |{{ user.get_favorites() }} |
  |Filter Arguments | {{ toppings|join:', ' }} | {{ toppings|join(', ') }} |
  |Loop Empty Argument | {% empty %} | {% else %} |
  |Loop Variable | {{ forloop }} | {{ loop }} |
  |Cycle | {% cycle 'odd' 'even' %} | {{ loop.cycle('odd','even') }} |
  
  ...etc.

### Should I Switch?

- In short, we can use multiple template languages together harmoniously, so you dont have to stick to one but if you are changing from DTL have a good reason.

<Br>
<Br>
<Br>
  
# Building REST APIs With Django REST Framework

- Today’s internet is much more than HTML-powered websites. Developers need to support AJAX
and native mobile apps. Having tools that support easy creation of JSON, YAML, XML, and other
formats is important. By design, a Representational State Transfer (REST) Application Programming Interface (API) exposes application data to other concerns.

  The defacto package for building these REST APIs with Django is Django REST Framework
(DRF).
  
- `WARNING` -- Sequential keys, such as what Django provides as a default as model primary keys, can be
a security concern if used publicly. We cover this in-depth at Section 26.27: Never Display
Sequential Primary Keys.
In our example, we’re going to use the model’s UUID rather than the model’s primary key to
look up our records. We always try to avoid using sequential numbers for lookups. 

### REST API Architecture

- Building simple, quick APIs is easy with Django REST Framework, but extending and maintaining
it to match your project’s needs takes a bit more thought. This is usually where people get hung up
on API design. Here are some tips for improving your design:

- `Use Consistent API Module Naming` -- Just like anything else, how things are named needs to be consistent across a project. Our preferences
for naming module related to API design is as follows:
  ```
  django_app/
  ├── api/
  │   ├── __init__.py
  │   ├── authentication.py
  │   ├── parsers.py
  │   ├── permissions.py
  │   ├── renderers.py
  │   ├── serializers.py
  │   ├── validators.py
  │   ├── views.py
  │   ├── viewsets.py
  ```
  -  We like to place all our API components into a package within an app called api/. That’s allows
us to isolate our API components in a consistent location. If we were to put it in the root of
our app, then we would end up with a huge list of API-specific modules in the general area of
the app
  - We always place routers in urls.py.
  
- `Try to Keep Business Logic Out of API Views` -- Regardless of which architectural approach you take, it’s a good idea to try to keep as much logic as
possible out of API views. If this sounds familiar, it should. We covered this in Section 8.5: Try to
Keep Business Logic Out of Views. Remember, at the end of the day, API views are just another
type of view

- `Grouping API urls` -- If you have REST API views in multiple Django apps, how do you build a project-wide API that
looks like this?
  ```
  api/flavors/ # GET, POST
  api/flavors/:uuid/ # GET, PUT, DELETE
  api/users/ # GET, POST
  api/users/:uuid/ # GET, PUT, DELETE
  ```
  Our current approach is to lean on URL configuration. When building a project-wide API we write
the REST views in the api/views.py or api/viewsets.py modules, wire them into a URLConf called
something like core/api_urls.py or core/apiv1_urls.py, and include that from the project root’s urls.py
module

- When we implement a new version of the API, we provide customers/users with a deprecation warning along with ample time so they can perform necessary upgrades and not break their own applications. From personal experience, the ability to send a deprecation warning to end users is an excellent
reason to request email addresses from users of even free and open source API services.

### Shutting Down an External API

- When it’s time to shut down an older version of an external API in favor of a new one, here are useful
steps to follow:
  - Step #1: Notify Users of Pending Shut Down
  - Step #2: Replace API With 410 Error View

### Rate-Limiting Your API

- Rate limiting is when an API restricts how many requests can be made by a user of the API within
a period of time. This is done for a number of reasons

  > It’s possible to use nginx or apache for rate limiting. The upside is faster performance. The
downside is that it removes this functionality from the Python code.

- Also Rate Limit Can Be a Business Plan We know that everyone will want to use this API, and come up with several tiers of access
that we tie into pricing:
  - Developer tier is free, but only allows 10 API requests per hour.
  - Two Scoops is $79/month, allows 50 requests per minute.
  - Corporate is $5000/month, allows for 200 requests per minute.

### Advertising Your REST API

- Let’s assume we’ve built our REST API and want outside coders and companies to use it. How do
we go about doing that?

- `Documentation` -- The most important thing to do is to provide comprehensive documentation. The easier to read
and understand the better. (Use slacks documentation as a inspiration it is fucking documented VERY WELL)

- `Provide Client SDKs` -- Something that may help spread use of your API is to provide a software development kits (SDK)
for various programming languages. The more programming languages covered the better. For us,
we’ve found the must-have languages include Python, JavaScript, Ruby, PHP, Go, and Java

<Br>
<Br>
<Br>
  
# Tradeoffs of Replacing Core Components

- There’s a lot of hype around swapping out core parts of Django’s stack for other pieces. Should you
do it?

  Short Answer: Don’t do it. Even the CEO of Instagram (Kevin Systrom) said Forbes.com that it’s
completely unnecessary (bit.ly/2pZxOBO).

###  Ignore the Hype and Do Your Own Research

- It’s often said that non-relational databases are faster and scale better than relational databases.
Whether or not this is true, don’t blindly swallow the marketing hype of the companies behind
any particular alternative database solution.

  Instead, do as we do: search for benchmarks, read case studies describing when things went right or
wrong, and form opinions as independently as possible

  Also, experiment with unfamiliar NoSQL databases on small hobby side projects before you make
major changes to your main project infrastructure. Your main codebase is not a playground.

<Br>
<Br>
<Br>
  
# Working With the Django Admin

### It’s Not for End Users

### Admin Customization vs. New Views

### Viewing String Representations of Objects

### Adding Callables to ModelAdmin Classes

### Be Aware of the Complications of Multiuser Environments

### Django’s Admin Documentation Generator

### Using Custom Skins With the Django Admin

### Secure the Django Admin

### Securing the Admin Docs

<Br>
<Br>
<Br>
  
# Dealing With the User Model

### Use Django’s Tools for Finding the User Model

### Custom User Fields for Django 1.11 Projects

<Br>
<Br>
<Br>
  
# Django’s Secret Sauce: Third-Party Packages 

### Examples of Third-Party Packages

### Know About the Python Package Index

### Know About DjangoPackages.org

### Know Your Resources

### Tools for Installing and Managing Packages

### Package Requirements

### Wiring Up Django Packages: The Basics

### Troubleshooting Third-Party Packages

### Releasing Your Own Django Packages

### What Makes a Good Django Package?

###  Creating Your Own Packages the Easy Way

### Maintaining Your Open Source Package

### Additional Reading

<Br>
<Br>
<Br>
  
# Testing Stinks and Is a Waste of Money!

### Testing Saves Money, Jobs, and Lives

### How to Structure Tests

### How to Write Unit Tests

### What About Integration Tests?

### Continuous Integration 

### Who Cares? We Don’t Have Time for Tests!

### The Game of Test Coverage

### Setting Up the Test Coverage Game

### Playing the Game of Test Coverage

### Alternatives to unittest

<Br>
<Br>
<Br>
  
# Documentation: Be Obsessed 

### Use reStructuredText for Python Docs

### Use Sphinx to Generate Documentation From reStructuredText

### What Docs Should Django Projects Contain?

### Additional Documentation Resources

### The Markdown Alternative

### Wikis and Other Documentation Methods

<br>
<br>
<br>

# Finding and Reducing Bottlenecks 

### Should You Even Care?

### Speed Up Query-Heavy Pages

### Get the Most Out of Your Database 

### Cache Queries With Memcached or Redis

### Identify Specific Places to Cache

### Consider Third-Party Caching Packages

### Compression and Minification of HTML, CSS, and JavaScript

### Use Upstream Caching or a Content Delivery Network

### Other Resources

<br>
<br>
<Br>
  
# Asynchronous Task Queues

### Do We Need a Task Queue?

### Choosing Task Queue Software

### Best Practices for Task Queues

### Resources for Task Queues

<br>
<br>
<Br>
  
# Security Best Practices

### Reference Security Sections in Other Chapters

### Harden Your Servers

### Know Django’s Security Features

### Turn Off DEBUG Mode in Production

### Keep Your Secret Keys Secret

### HTTPS Everywhere

### Use Allowed Hosts Validation

###  Always Use CSRF Protection With HTTP Forms That Modify Data

### Prevent Against Cross-Site Scripting (XSS) Attacks

### Defend Against Python Code Injection Attacks

### Validate All Incoming Data With Django Forms

### Disable the Autocomplete on Payment Fields

### Handle User-Uploaded Files Carefully

### Don’t Use ModelForms.Meta.exclude

### Don’t Use ModelForms.Meta.fields = ”__all__”

### Beware of SQL Injection Attacks

### Never Store Credit Card Data

### Monitor Your Sites

### Keep Your Dependencies Up-to-Date

### Prevent Clickjacking

### Guard Against XML Bombing With defusedxml

### Explore Two-Factor Authentication

### Embrace SecurityMiddleware

### Force the Use of Strong Passwords

### Give Your Site a Security Checkup

### Put Up a Vulnerability Reporting Page

### Never Display Sequential Primary Keys

### Reference Our Security Settings Appendix

### Review the List of Security Packages

### Keep Up-to-Date on General Security Practices

<br>
<br>
<Br>
  
# Logging: What’s It For, Anyway?

### Application Logs vs. Other Logs

### Why Bother With Logging?

### When to Use Each Log Level

### Log Tracebacks When Catching Exceptions

### One Logger Per Module That Uses Logging 

### Log Locally to Rotating Files

### Other Logging Tips

### Necessary Reading Material

### Useful Third-Party Tools

<br>
<br>
<Br>
  
# Signals: Use Cases and Avoidance Techniques

### When to Use and Avoid Signals

### Signal Avoidance Techniques

<br>
<br>
<Br>
  
# What About Those Random Utilities? 

### Create a Core App for Your Utilities

### Optimize Apps With Utility Modules

### Django’s Own Swiss Army Knife

### Exceptions

### Serializers and Deserializers

<br>
<br>
<Br>
   
# Deployment: Platforms as a Service

### Evaluating a PaaS

### Best Practices for Deploying to PaaS

<br>
<br>
<Br>
  
# Deploying Django Projects

### Single-Server for Small Projects

### Multi-Server for Medium to Large Projects 

### WSGI Application Servers

### Performance and Tuning: uWSGI and Gunicorn

### Stability and Ease of Setup: Gunicorn and Apache

### Common Apache Gotchas

### Automated, Repeatable Deployments

### Which Automation Tool Should Be Used?

### Current Infrastructure Automation Tools

### Other Resources

<br>
<br>
<Br>
  
# Continuous Integration

### Principles of Continuous Integration

### Tools for Continuously Integrating Your Project

### Continuous Integration as a Service

### Additional Resources

<br>
<br>
<Br>
  
# The Art of Debugging

### Debugging in Development

### Debugging Production Systems

###  Feature Flags

<br>
<br>
<Br>
  
# Where and How to Ask Django Questions

### What to Do When You’re Stuck

### How to Ask Great Django Questions in IRC

### Feed Your Brain

### Insider Tip: Be Active in the Community

  
